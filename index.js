// Copyright (c) 2018 PROPHESSOR
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

'use strict';

const fs = require('fs');

const MapParser = require('./MapParser');
const BoomParser = require('./BoomParser');

const [
	Linedef,
	Sector,
	Thing,
	Sidedef,
	Vertex
] = [
	require('./structures/linedef'),
	require('./structures/sector'),
	require('./structures/thing'),
	require('./structures/sidedef'),
	require('./structures/vertex')
];

const VERTEXES = 'input/VERTEXES.lmp';
const LINEDEFS = 'input/LINEDEFS.lmp';
const SECTORS = 'input/SECTORS.lmp';
const THINGS = 'input/THINGS.lmp';
const SIDEDEFS = 'input/SIDEDEFS.lmp';

const TEXTMAP = 'output/TEXTMAP';

function parseVertexes() {
	const vertexes = MapParser.getVertexes(VERTEXES);

	const out = [];

	for (const i in vertexes) {
		const vertex = vertexes[i];

		out.push(new Vertex(i, vertex.x, vertex.y));
	}

	let outstring = '// Vertexes\n';

	for (const vertex of out) {
		console.log(vertex.toString());
		outstring += vertex.toString();
	}

	return outstring;
}

function parseThings() {
	const things = MapParser.getThings(THINGS);

	const out = [];

	for (const i in things) {
		const thing = things[i];

		out.push(new Thing(i, thing.x, thing.y, thing.angle, thing.tid, BoomParser.Thing.getUDMFflags(thing.flags)));
	}

	let outstring = '// Things\n';

	for (const thing of out) {
		console.log(thing.toString());
		outstring += thing.toString();
	}

	return outstring;
}

function parseSectors() {
	const sectors = MapParser.getSectors(SECTORS);

	const out = [];

	for (const i in sectors) {
		const sector = sectors[i];

		out.push(new Sector(i, sector.floor, sector.height, sector.floortex, sector.ceiltex, sector.light, sector.special, sector.tag));
	}

	let outstring = '// Sectors\n';

	for (const sector of out) {
		console.log(sector.toString());
		outstring += sector.toString();
	}

	return outstring;
}

function parseLinedefs() {
	const linedefs = MapParser.getLinedefs(LINEDEFS);

	const out = [];

	for (const i in linedefs) {
		const linedef = linedefs[i];

		const boom2udmf = new BoomParser.Action(
			linedef.action, //
			{
				'flags': linedef.flags,
				'tag': linedef.tag,
				'front': linedef.front,
				'back': linedef.back,
				'lineid': i
			}
		);

		const attributes = {
			'arg1': boom2udmf.arg1,
			'arg2': boom2udmf.arg2,
			'arg3': boom2udmf.arg3,
			'arg4': boom2udmf.arg4,
			'arg5': boom2udmf.arg5
		};

		out.push(new Linedef(i, linedef.v1, linedef.v2, boom2udmf.UDMFflags, boom2udmf.UDMFaction, attributes, linedef.front, linedef.back, {'flag': linedef.flags}));
	}

	let outstring = '// LineDefs\n';

	for (const linedef of out) {
		console.log(linedef.toString());
		outstring += linedef.toString();
	}

	return outstring;
}

function parseSidedefs() {
	const sidedefs = MapParser.getSides(SIDEDEFS);

	const out = [];

	for (const i in sidedefs) {
		const sidedef = sidedefs[i];

		out.push(new Sidedef(i, sidedef.offsetx, sidedef.offsety, sidedef.uppertex, sidedef.lowertex, sidedef.middletex, sidedef.sector));
	}

	let outstring = '// SideDefs\n';

	for (const sidedef of out) {
		console.log(sidedef.toString());
		outstring += sidedef.toString();
	}

	return outstring;
}

let output = '// Generated by Boom2UDMF\n\nnamespace = "ZDoom";\n';

output += parseThings();
output += parseVertexes();
output += parseLinedefs();
output += parseSidedefs();
output += parseSectors();
output += '\n\n// End of file';

fs.writeFileSync(TEXTMAP, output, 'utf8');
