// Copyright (c) 2018-2022 PROPHESSOR
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

import {
  Linedef, Sector, Thing, Sidedef, Vertex,
} from './structures';
import MapParserInstance from './MapParser';
import { BoomParser } from './BoomParser';

// eslint-disable-next-line
import ByteTools from './utils/ByteTools'; // For typings
import { WadParser } from './WadParser';

/**
 *
 * @param {ByteTools} wadBuffer
 * @param {function} stage
 * @returns {WadLump[]}
 */
export async function parseMaps(wadBuffer, stage) {
  await stage('Parsing WAD...');
  const wad = new WadParser(wadBuffer);
  await wad.parse();
  await stage(`Found ${wad.lumps.length} lumps!`);

  const maps = wad.getMaps();
  await stage(`Found ${maps.length} maps!`);

  return [wad, maps];
}

/**
 *
 * @param {WadParser} wadParser
 * @param {number} mapIndex
 * @param {function} stage
 * @returns
 */
export async function boom2Udmf(wadParser, mapIndex, stage) {
  const {
    THINGS, VERTEXES, LINEDEFS, SIDEDEFS, SECTORS,
  } = wadParser.getMapLumps(mapIndex);

  const thingsBuffer = THINGS.read();
  const vertexesBuffer = VERTEXES.read();
  const linedefsBuffer = LINEDEFS.read();
  const sidedefsBuffer = SIDEDEFS.read();
  const sectorsBuffer = SECTORS.read();

  return generateUdmf(
    thingsBuffer, vertexesBuffer, linedefsBuffer, sidedefsBuffer, sectorsBuffer, stage,
  );
}

/**
 *
 * @param {ByteTools} thingBuffer
 * @param {ByteTools} vertexBuffer
 * @param {ByteTools} lineBuffer
 * @param {ByteTools} sideBuffer
 * @param {ByteTools} sectorBuffer
 * @returns
 */
export async function generateUdmf(
  thingBuffer, vertexBuffer, lineBuffer, sideBuffer, sectorBuffer, stage,
) {
  await stage('Generating UDMF...');
  let output = '// Generated by Boom2UDMF\n\nnamespace = "ZDoom";\n';
  output += parseThings(thingBuffer);
  await stage('Things - DONE!');
  output += parseVertexes(vertexBuffer);
  await stage('Vertexes - DONE!');
  output += parseLinedefs(lineBuffer);
  await stage('Lines - DONE!');
  output += parseSidedefs(sideBuffer);
  await stage('Sides - DONE!');
  output += parseSectors(sectorBuffer);
  await stage('Sectors - DONE');
  output += '\n\n// End of file';
  await stage('Complete!');

  return output;
}

/**
 *
 * @param {ByteTools} buffer
 * @returns
 */
function parseVertexes(buffer) {
  const vertexes = MapParserInstance.getVertexes(buffer);

  const out = [];

  vertexes.forEach((vertex, i) => {
    out.push(new Vertex(i, vertex.x, vertex.y));
  });

  let outstring = '// Vertexes\n';

  out.forEach((vertex) => {
    console.log(vertex.toString());
    outstring += vertex.toString();
  });

  return outstring;
}

/**
 *
 * @param {ByteTools} buffer
 * @returns
 */
function parseThings(buffer) {
  const things = MapParserInstance.getThings(buffer);

  const out = [];

  things.forEach((thing, i) => {
    out.push(new Thing(
      i, thing.x, thing.y, thing.angle, thing.tid,
      BoomParser.Thing.getUDMFflags(thing.flags),
    ));
  });

  let outstring = '// Things\n';

  out.forEach((thing) => {
    console.log(thing.toString());
    outstring += thing.toString();
  });

  return outstring;
}

/**
 *
 * @param {ByteTools} buffer
 * @returns
 */
function parseSectors(buffer) {
  const sectors = MapParserInstance.getSectors(buffer);

  const out = [];

  sectors.forEach((sector, i) => {
    out.push(new Sector(
      i, sector.floor, sector.height, sector.floortex, sector.ceiltex,
      sector.light, sector.special, sector.tag,
    ));
  });

  let outstring = '// Sectors\n';

  out.forEach((sector) => {
    console.log(sector.toString());
    outstring += sector.toString();
  });

  return outstring;
}

/**
 *
 * @param {ByteTools} buffer
 * @returns
 */
function parseLinedefs(buffer) {
  const linedefs = MapParserInstance.getLinedefs(buffer);

  const out = [];

  linedefs.forEach((linedef, i) => {
    const boom2udmf = new BoomParser.Action(
      linedef.action, //
      {
        flags: linedef.flags,
        tag: linedef.tag,
        front: linedef.front,
        back: linedef.back,
        lineid: i,
      },
    );

    const attributes = {
      arg1: boom2udmf.arg1,
      arg2: boom2udmf.arg2,
      arg3: boom2udmf.arg3,
      arg4: boom2udmf.arg4,
      arg5: boom2udmf.arg5,
    };

    out.push(new Linedef(
      i, linedef.v1, linedef.v2, boom2udmf.UDMFflags, boom2udmf.UDMFaction,
      attributes, linedef.front, linedef.back, { flag: linedef.flags },
    ));
  });

  let outstring = '// LineDefs\n';

  out.forEach((linedef) => {
    console.log(linedef.toString());
    outstring += linedef.toString();
  });

  return outstring;
}

/**
 *
 * @param {ByteTools} buffer
 * @returns
 */
function parseSidedefs(buffer) {
  const sidedefs = MapParserInstance.getSides(buffer);

  const out = [];

  sidedefs.forEach((sidedef, i) => {
    out.push(new Sidedef(
      i, sidedef.offsetx, sidedef.offsety, sidedef.uppertex, sidedef.lowertex,
      sidedef.middletex, sidedef.sector,
    ));
  });

  let outstring = '// SideDefs\n';

  out.forEach((sidedef) => {
    console.log(sidedef.toString());
    outstring += sidedef.toString();
  });

  return outstring;
}
