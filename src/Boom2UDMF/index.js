// Copyright (c) 2018-2022 PROPHESSOR
//
// This software is released under the MIT License.
// https://opensource.org/licenses/MIT

import {
  Linedef, Sector, Thing, Sidedef, Vertex,
} from './structures';
import MapParserInstance from './MapParser';
import { BoomParser } from './BoomParser';

// eslint-disable-next-line
import ByteTools from './utils/ByteTools'; // For typings

/**
 *
 * @param {ByteTools} thingBuffer
 * @param {ByteTools} vertexBuffer
 * @param {ByteTools} lineBuffer
 * @param {ByteTools} sideBuffer
 * @param {ByteTools} sectorBuffer
 * @returns
 */
export function generateUdmf(thingBuffer, vertexBuffer, lineBuffer, sideBuffer, sectorBuffer) {
  let output = '// Generated by Boom2UDMF\n\nnamespace = "ZDoom";\n';

  output += parseThings(thingBuffer);
  output += parseVertexes(vertexBuffer);
  output += parseLinedefs(lineBuffer);
  output += parseSidedefs(sideBuffer);
  output += parseSectors(sectorBuffer);
  output += '\n\n// End of file';

  return output;
}

/**
 *
 * @param {ByteTools} buffer
 * @returns
 */
function parseVertexes(buffer) {
  const vertexes = MapParserInstance.getVertexes(buffer);

  const out = [];

  vertexes.forEach((vertex, i) => {
    out.push(new Vertex(i, vertex.x, vertex.y));
  });

  let outstring = '// Vertexes\n';

  out.forEach((vertex) => {
    console.log(vertex.toString());
    outstring += vertex.toString();
  });

  return outstring;
}

/**
 *
 * @param {ByteTools} buffer
 * @returns
 */
function parseThings(buffer) {
  const things = MapParserInstance.getThings(buffer);

  const out = [];

  things.forEach((thing, i) => {
    out.push(new Thing(
      i, thing.x, thing.y, thing.angle, thing.tid,
      BoomParser.Thing.getUDMFflags(thing.flags),
    ));
  });

  let outstring = '// Things\n';

  out.forEach((thing) => {
    console.log(thing.toString());
    outstring += thing.toString();
  });

  return outstring;
}

/**
 *
 * @param {ByteTools} buffer
 * @returns
 */
function parseSectors(buffer) {
  const sectors = MapParserInstance.getSectors(buffer);

  const out = [];

  sectors.forEach((sector, i) => {
    out.push(new Sector(
      i, sector.floor, sector.height, sector.floortex, sector.ceiltex,
      sector.light, sector.special, sector.tag,
    ));
  });

  let outstring = '// Sectors\n';

  out.forEach((sector) => {
    console.log(sector.toString());
    outstring += sector.toString();
  });

  return outstring;
}

/**
 *
 * @param {ByteTools} buffer
 * @returns
 */
function parseLinedefs(buffer) {
  const linedefs = MapParserInstance.getLinedefs(buffer);

  const out = [];

  linedefs.forEach((linedef, i) => {
    const boom2udmf = new BoomParser.Action(
      linedef.action, //
      {
        flags: linedef.flags,
        tag: linedef.tag,
        front: linedef.front,
        back: linedef.back,
        lineid: i,
      },
    );

    const attributes = {
      arg1: boom2udmf.arg1,
      arg2: boom2udmf.arg2,
      arg3: boom2udmf.arg3,
      arg4: boom2udmf.arg4,
      arg5: boom2udmf.arg5,
    };

    out.push(new Linedef(
      i, linedef.v1, linedef.v2, boom2udmf.UDMFflags, boom2udmf.UDMFaction,
      attributes, linedef.front, linedef.back, { flag: linedef.flags },
    ));
  });

  let outstring = '// LineDefs\n';

  out.forEach((linedef) => {
    console.log(linedef.toString());
    outstring += linedef.toString();
  });

  return outstring;
}

/**
 *
 * @param {ByteTools} buffer
 * @returns
 */
function parseSidedefs(buffer) {
  const sidedefs = MapParserInstance.getSides(buffer);

  const out = [];

  sidedefs.forEach((sidedef, i) => {
    out.push(new Sidedef(
      i, sidedef.offsetx, sidedef.offsety, sidedef.uppertex, sidedef.lowertex,
      sidedef.middletex, sidedef.sector,
    ));
  });

  let outstring = '// SideDefs\n';

  out.forEach((sidedef) => {
    console.log(sidedef.toString());
    outstring += sidedef.toString();
  });

  return outstring;
}
